<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Knitting Graph with Multiple Charts</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 1rem; 
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .header {
      background: #2c3e50;
      color: white;
      padding: 1rem;
      text-align: center;
    }
    
    .tabs {
      display: flex;
      background: #34495e;
      border-bottom: 1px solid #2c3e50;
    }
    
    .tab {
      flex: 1;
      padding: 1rem;
      background: #34495e;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s;
    }
    
    .tab:hover {
      background: #3d566e;
    }
    
    .tab.active {
      background: #3498db;
    }
    
    .tab-content {
      display: none;
      padding: 1rem;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .chart-container {
      text-align: center;
      margin-bottom: 1rem;
      width: 100%;
      overflow: auto;
    }
    
    svg { 
      background: #fafafa; 
      border: 1px solid #ddd;
      border-radius: 4px;
      max-width: 100%;
      height: auto;
    }
    
    .k { fill: #4A90E2; stroke: #333; stroke-width: 0; }
    .p { fill: #524be3; stroke: #333; stroke-width: 0; }
    .inc { fill: #85DCB0; stroke: #333; stroke-width: 0; }
    .dec { fill: #E27D60; stroke: #333; stroke-width: 0; }
    .nostitch { fill: transparent; stroke: #333; stroke-width: 0; }
    .strand { fill: #fff; stroke: #666; stroke-width: 0; }
    .link { stroke: #aaa; stroke-width: 0; }
    
    .controls {
      margin: 1rem 0;
      text-align: center;
    }
    
    .btn {
      background: #3498db;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      margin: 0 0.5rem;
      font-size: 0.9rem;
    }
    
    .btn:hover {
      background: #2980b9;
    }
    
    .loading {
      text-align: center;
      padding: 2rem;
      color: #666;
    }
    
    .chart-info {
      margin: 0.5rem 0;
      font-size: 0.9rem;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Knitting Graph Renderer</h1>
      <p>Multiple Chart Sections with Dynamic Scaling</p>
    </div>
    
    <div class="tabs" id="tabs">
      <!-- Tabs will be generated dynamically -->
    </div>
    
    <div class="tab-content active" id="loading">
      <div class="loading">
        <h3>Loading charts...</h3>
        <p>Please wait while we load the knitting charts.</p>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let chartsData = [];
    let currentChartIndex = 0;
    
    // Gauge settings
    const GAUGE = {
      stitchesPerInch: 5.50,
      rowsPerInch: 7.50,
      marginInches: 0.00
    };
    
    const rowSpacing = 75;

    // Load charts data
    async function loadChartsData() {
      try {
        const response = await fetch('engine2/charts.json');
        const data = await response.json();
        chartsData = data.charts;
        
        // Initialize the interface
        initializeInterface();
      } catch (error) {
        console.error('Error loading charts data:', error);
        // Fallback: try to load individual files
        await loadIndividualCharts();
      }
    }
    
    // Fallback: load individual chart files
    async function loadIndividualCharts() {
      const chartFiles = ['left_front.json', 'right_front.json'];
      chartsData = [];
      
      for (const file of chartFiles) {
        try {
          const response = await fetch(`engine2/${file}`);
          const data = await response.json();
          chartsData.push(data);
        } catch (error) {
          console.warn(`Could not load ${file}:`, error);
        }
      }
      
      if (chartsData.length > 0) {
        initializeInterface();
      } else {
        document.getElementById('loading').innerHTML = 
          '<div class="loading"><h3>No charts found</h3><p>Please generate some charts first.</p></div>';
      }
    }

    // Initialize the tabbed interface
    function initializeInterface() {
      const tabsContainer = document.getElementById('tabs');
      const loadingTab = document.getElementById('loading');
      
      // Remove loading tab
      loadingTab.remove();
      
      // Create tabs for each chart
      chartsData.forEach((chart, index) => {
        // Create tab button
        const tabButton = document.createElement('button');
        tabButton.className = `tab ${index === 0 ? 'active' : ''}`;
        tabButton.textContent = chart.name.replace('_', ' ').toUpperCase();
        tabButton.onclick = () => switchTab(index);
        tabsContainer.appendChild(tabButton);
        
        // Create tab content
        const tabContent = document.createElement('div');
        tabContent.className = `tab-content ${index === 0 ? 'active' : ''}`;
        tabContent.id = `chart-${index}`;
        
        tabContent.innerHTML = `
          <div class="chart-container">
            <h3>${chart.name.replace('_', ' ').toUpperCase()}</h3>
            <div class="chart-info" id="info-${index}">Loading...</div>
            <svg id="chart-${index}-svg" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
          <div class="controls">
            <button class="btn" onclick="downloadChart(${index})">Download ${chart.name.replace('_', ' ')} SVG</button>
          </div>
        `;
        
        document.querySelector('.container').appendChild(tabContent);
      });
      
      // Initialize the first chart
      if (chartsData.length > 0) {
        initializeVisualization(0);
      }
    }
    
    // Switch between tabs
    function switchTab(index) {
      // Update tab buttons
      document.querySelectorAll('.tab').forEach((tab, i) => {
        tab.classList.toggle('active', i === index);
      });
      
      // Update tab content
      document.querySelectorAll('.tab-content').forEach((content, i) => {
        content.classList.toggle('active', i === index);
      });
      
      // Initialize visualization for the selected chart if not already done
      const svg = document.getElementById(`chart-${index}-svg`);
      if (svg && !svg.hasAttribute('data-initialized')) {
        initializeVisualization(index);
      }
      
      currentChartIndex = index;
    }
    
    // Initialize visualization for a specific chart
    function initializeVisualization(chartIndex) {
      const chart = chartsData[chartIndex];
      const svg = d3.select(`#chart-${chartIndex}-svg`);
      
      // Mark as initialized
      svg.node().setAttribute('data-initialized', 'true');
      
      const nodes = chart.nodes;
      const links = chart.links;
      
      // Update chart info
      const infoElement = document.getElementById(`info-${chartIndex}`);
      infoElement.textContent = `${nodes.length} nodes, ${links.length} links`;
      
      // Calculate dimensions once (since positions are fixed)
      const positionedNodes = nodes.filter(d => d.fx !== undefined || d.fy !== undefined);
      
      if (positionedNodes.length === 0) return;

      const minX = d3.min(positionedNodes, d => d.fx);
      const maxX = d3.max(positionedNodes, d => d.fx);
      const minY = d3.min(positionedNodes, d => d.fy);
      const maxY = d3.max(positionedNodes, d => d.fy);

      const padding = 100;
      const width = maxX - minX + 2 * padding;
      const height = maxY - minY + 2 * padding;

      // Set SVG dimensions once
      svg.attr("width", Math.max(400, width))
        .attr("height", Math.max(300, height))
        .attr("viewBox", `${minX - padding} ${minY - padding} ${width} ${height}`);
      
      // Update chart info with dimensions
      infoElement.textContent = `${nodes.length} nodes, ${links.length} links (${Math.round(width)}Ã—${Math.round(height)}px)`;

      // Draw links once (no simulation needed)
      const link = svg.append("g")
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("class", "link")
        .attr("x1", d => d.source.fx || d.source.x)
        .attr("y1", d => d.source.fy || d.source.y)
        .attr("x2", d => d.target.fx || d.target.x)
        .attr("y2", d => d.target.fy || d.target.y);

      // Draw nodes once (no simulation needed)
      const node = svg.append("g")
        .selectAll("circle")
        .data(nodes)
        .join("circle")
        .attr("r", d => d.type === "k" || d.type === "p" || d.type === "inc" || d.type === "dec" ? 5 : 2)
        .attr("cx", d => d.fx || d.x)
        .attr("cy", d => d.fy || d.y)
        .attr("fill", d => {
          if (d.type === "k") return "#4A90E2";
          if (d.type === "p") return "#524be3";
          if (d.type === "inc") return "#85DCB0";
          if (d.type === "dec") return "#E27D60";
          return "transparent";
        })
        .attr("stroke", d => (d.type === "k" || d.type === "p" || d.type === "inc" || d.type === "dec") ? "#333" : "none")
        .attr("stroke-width", 0.5)
        .attr("opacity", d => d.type === "strand" ? 0 : 1)
        .style("pointer-events", d => d.type === "strand" ? "none" : "auto")
        .style("cursor", "pointer")
        .on("click", function(event, d) {
          d3.select(this).attr("fill", "black");
        });

      // Draw labels once
      const labels = svg.append("g")
        .selectAll("text")
        .data(nodes)
       
        .text(d => d.type === "strand" ? "" : d.id)
        .attr("font-size", 11)
        .attr("text-anchor", "middle")
        .attr("dy", 4)
        .attr("x", d => d.fx || d.x)
        .attr("y", d => (d.fy || d.y) + 35);
    }
    // Download chart function
    function downloadChart(chartIndex) {
  const chart = chartsData[chartIndex];
  const svgEl = document.getElementById(`chart-${chartIndex}-svg`);
  if (!svgEl) return;

  const clone = svgEl.cloneNode(true);

  // --- Basic cleanup ---
  clone.querySelectorAll('[opacity="0"], [display="none"]').forEach(el => el.remove());
  clone.removeAttribute('data-initialized');

  // Remove <title> or <desc> tags if they exist
  clone.querySelectorAll('title, desc').forEach(el => el.remove());

  // Round numeric values to reduce text length
  const serializer = new XMLSerializer();
  let source = serializer.serializeToString(clone);

  // Compress by rounding coordinates & trimming whitespace
  source = source
    .replace(/(\d+\.\d{3,})/g, (m) => Number(m).toFixed(2)) // round to 2 decimals
    .replace(/\s{2,}/g, ' ')                               // collapse spaces
    .replace(/>[\s\n]+</g, '><');                          // remove newlines between tags

  // Ensure xmlns
  if (!source.match(/^<svg[^>]+xmlns=/)) {
    source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  source = '<?xml version="1.0" standalone="no"?>\n' + source;

  // Create data URL
  const blob = new Blob([source], { type: "image/svg+xml" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `${chart.name}-compressed.svg`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
    // Start the application
    loadChartsData();
  </script>
</body>
</html>